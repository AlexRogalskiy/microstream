= Use Data Copy

If we work in MVC frameworks, our work is done by getting some data from data source, modifying it
and then store it in a datastore. In this style of work we always work with a copy of the data.
Which allows us to use mutable data only within a single thread, we don't have to worry about data
synchronization and then store this data in a database transaction.
This way of working is very practical, it does not require developers to have knowledge of multithreaded
programming and thanks to this it is very widespread.


Can similar technical work be used when working with Microstream?

Of course, elegantly, very simply and safely we can use the ObjectCopier utility to create a Deep Copy of our data,
change it and save it back.

== Deep Copy vs Shallow Copy
Very simple idea, we create a purchase of actual data to work with in the application and at the end
save that data back. Unfortunately, it's not that simple. If we call copy over an object in Java,
it creates a copy of that object, but the other object references remain the same. This doesn't help us much.
Because usually we have a more complex data structure than a single object. This approach is called shallow copy.
More here: https://en.wikipedia.org/wiki/Object_copying

What we actually need is a deep copy. We need to have a copy of whole data subgraph from one object.

== Deep Copy Utility (ObjectCopier)
Microstream provides the full support for deep copy. However, the following conditions must be met:

[WARNING]
====
. Data must be already saved and manage by Microstream.
. We have no circular reference. Our Object Graph is a Tree. (From graph theory, object graph contains no circles.)
====

If we meet the above conditions, you can relatively easily call ObjectCopier and create a deep copy of our data.

[source, java]
----
        ObjectCopier objectCopier = ObjectCopier.New();

        Customer customer = root.getCustomer(id);

        Customer customerCopy = objectCopier.copy(customer);
        customerCopy.addPurchase(purchase);

        XThreads.executeSynchronized(() -> {
            root.setCustomer(id, customerCopy);
            storage.store(root.getcusomers());
        }
----

What we are doing now?

. We create instance of ObjectCopier class due to factory method New();
. We get customer
. Make deep copy of customer object
. Modify this object graph
. In synchronized mode save this customer instead of original customer and save it into datastore

This simple example written in pseudocode aims to demonstrate one of the many ways to solve
working over a shared object graph in a multi-threaded environment.

